// Generated by CoffeeScript 1.9.0
(function() {
  var Hashmap, OptimizedModel, compactClasses, createEquivalenceClasses, createModelFromEquivalenceClass, separateGeometry,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  OptimizedModel = require('./OptimizedModel');

  separateGeometry = function(optimizedModel) {
    var eq, equivalenceClasses, models, _i, _len;
    equivalenceClasses = createEquivalenceClasses(optimizedModel);
    if (equivalenceClasses.length === 1) {
      return [optimizedModel];
    }
    models = [];
    for (_i = 0, _len = equivalenceClasses.length; _i < _len; _i++) {
      eq = equivalenceClasses[_i];
      models.push(createModelFromEquivalenceClass(eq, optimizedModel));
    }
    return models;
  };

  createModelFromEquivalenceClass = function(equivalenceClass, optimizedModel) {
    var insertPoint, model, nextPointIndex, polyTranslationTable;
    nextPointIndex = 0;
    polyTranslationTable = {};
    model = new OptimizedModel();
    insertPoint = function(currentId) {
      if (polyTranslationTable[currentId] == null) {
        polyTranslationTable[currentId] = nextPointIndex;
        nextPointIndex++;
        model.positions.push(optimizedModel.positions[currentId * 3 + 0]);
        model.positions.push(optimizedModel.positions[currentId * 3 + 1]);
        model.positions.push(optimizedModel.positions[currentId * 3 + 2]);
        model.vertexNormals.push(optimizedModel.vertexNormals[currentId * 3 + 0]);
        model.vertexNormals.push(optimizedModel.vertexNormals[currentId * 3 + 1]);
        model.vertexNormals.push(optimizedModel.vertexNormals[currentId * 3 + 2]);
      }
      return polyTranslationTable[currentId];
    };
    equivalenceClass.polygons.enumerate(function(pi) {
      var p0, p0n, p1, p1n, p2, p2n;
      p0 = optimizedModel.indices[pi * 3 + 0];
      p1 = optimizedModel.indices[pi * 3 + 1];
      p2 = optimizedModel.indices[pi * 3 + 2];
      p0n = insertPoint(p0);
      p1n = insertPoint(p1);
      p2n = insertPoint(p2);
      model.indices.push(p0n);
      model.indices.push(p1n);
      model.indices.push(p2n);
      model.faceNormals.push(optimizedModel.faceNormals[pi * 3 + 0]);
      model.faceNormals.push(optimizedModel.faceNormals[pi * 3 + 1]);
      return model.faceNormals.push(optimizedModel.faceNormals[pi * 3 + 2]);
    });
    return model;
  };

  createEquivalenceClasses = function(optimizedModel) {
    var combined, connectedClasses, eq, equivalenceClasses, poly, polygonIndex, _i, _j, _len, _ref;
    equivalenceClasses = [];
    for (polygonIndex = _i = 0, _ref = optimizedModel.indices.length - 1; _i <= _ref; polygonIndex = _i += 3) {
      poly = {
        index: polygonIndex / 3,
        p0: optimizedModel.indices[polygonIndex],
        p1: optimizedModel.indices[polygonIndex + 1],
        p2: optimizedModel.indices[polygonIndex + 2]
      };
      connectedClasses = [];
      for (_j = 0, _len = equivalenceClasses.length; _j < _len; _j++) {
        eq = equivalenceClasses[_j];
        if (eq.points.exists(poly.p0) || eq.points.exists(poly.p1) || eq.points.exists(poly.p2)) {
          eq.points.push(poly.p0);
          eq.points.push(poly.p1);
          eq.points.push(poly.p2);
          eq.polygons.push(poly.index);
          connectedClasses.push(eq);
        }
      }
      if (connectedClasses.length === 0) {
        eq = {
          points: new Hashmap(),
          polygons: new Hashmap()
        };
        eq.points.push(poly.p0);
        eq.points.push(poly.p1);
        eq.points.push(poly.p2);
        eq.polygons.push(poly.index);
        equivalenceClasses.push(eq);
      } else if (connectedClasses.length > 1) {
        combined = compactClasses(connectedClasses);
        equivalenceClasses.push(combined);
        equivalenceClasses = equivalenceClasses.filter(function(a) {
          return a.points.length > 0;
        });
      }
    }
    return equivalenceClasses;
  };

  compactClasses = function(equivalenceClasses) {
    var eq, newClass, _i, _len;
    newClass = {
      points: new Hashmap(),
      polygons: new Hashmap()
    };
    for (_i = 0, _len = equivalenceClasses.length; _i < _len; _i++) {
      eq = equivalenceClasses[_i];
      eq.points.enumerate(function(point) {
        return newClass.points.push(point);
      });
      eq.polygons.enumerate(function(polygon) {
        return newClass.polygons.push(polygon);
      });
      eq.points = new Hashmap();
      eq.polygons = new Hashmap();
    }
    return newClass;
  };

  module.exports = separateGeometry;

  Hashmap = (function() {
    function Hashmap() {
      this.enumerate = __bind(this.enumerate, this);
      this.exists = __bind(this.exists, this);
      this.push = __bind(this.push, this);
      this.length = 0;
      this._enumarray = [];
      this._existsarray = [];
    }

    Hashmap.prototype.push = function(number) {
      if (!this._existsarray[number]) {
        this.length++;
        this._existsarray[number] = true;
        return this._enumarray.push(number);
      }
    };

    Hashmap.prototype.exists = function(number) {
      if (this._existsarray[number] != null) {
        return true;
      }
      return false;
    };

    Hashmap.prototype.enumerate = function(callback) {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this._enumarray.length - 1; _i <= _ref; i = _i += 1) {
        _results.push(callback(this._enumarray[i]));
      }
      return _results;
    };

    return Hashmap;

  })();

}).call(this);
