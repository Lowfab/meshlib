// Generated by CoffeeScript 1.9.0
(function() {
  var OptimizedModel, THREE, base64ByteLength, stringToUint8Array,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  THREE = require('three');

  base64ByteLength = function(base64Length) {
    return (base64Length / 4) * 3;
  };

  stringToUint8Array = function(str) {
    var ab, i, uintarray, _i, _ref;
    ab = new ArrayBuffer(str.length);
    uintarray = new Uint8Array(ab);
    for (i = _i = 0, _ref = str.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      uintarray[i] = str.charCodeAt(i);
    }
    return uintarray;
  };

  OptimizedModel = (function() {
    function OptimizedModel() {
      this.forEachPolygon = __bind(this.forEachPolygon, this);
      this.fromThreeGeometry = __bind(this.fromThreeGeometry, this);
      this.vertices = [];
      this.indices = [];
      this.verticesNormals = [];
      this.facesNormals = [];
      this.originalFileName = 'Unknown file';
    }

    OptimizedModel.prototype.isTwoManifold = function() {
      var a, addEdge, b, c, edges, i, num, numEdges, r, _i, _j, _len, _ref;
      if (this._isTwoManifold != null) {
        return this._isTwoManifold;
      }
      edges = [];
      numEdges = [];
      addEdge = function(a, b) {
        var aeb, bea, i, _i, _ref;
        for (i = _i = 0, _ref = edges.length - 1; _i <= _ref; i = _i += 1) {
          aeb = edges[i].a === a && edges[i].b === b;
          bea = edges[i].a === b && edges[i].b === a;
          if (aeb || bea) {
            numEdges[i]++;
            if (numEdges[i] > 2) {
              return false;
            } else {
              return true;
            }
          }
        }
        edges.push({
          a: a,
          b: b
        });
        return numEdges.push(1);
      };
      for (i = _i = 0, _ref = this.indices.length - 1; _i <= _ref; i = _i += 3) {
        a = this.indices[i];
        b = this.indices[i + 1];
        c = this.indices[i + 2];
        r = addEdge(a, b);
        r = addEdge(b, c) && r;
        r = addEdge(c, a) && r;
        if (!r) {
          this._isTwoManifold = false;
          return this._isTwoManifold;
        }
      }
      for (_j = 0, _len = numEdges.length; _j < _len; _j++) {
        num = numEdges[_j];
        if (num !== 2) {
          this._isTwoManifold = false;
          return this._isTwoManifold;
        }
      }
      this._isTwoManifold = true;
      return this._isTwoManifold;
    };

    OptimizedModel.prototype.toBase64 = function() {
      var baseString, fnA, fnBase, i, indA, indBase, posA, posBase, vnA, vnBase, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      posA = new Float32Array(this.vertices.length);
      for (i = _i = 0, _ref = this.vertices.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        posA[i] = this.vertices[i];
      }
      indA = new Int32Array(this.indices.length);
      for (i = _j = 0, _ref1 = this.indices.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        indA[i] = this.indices[i];
      }
      vnA = new Float32Array(this.verticesNormals.length);
      for (i = _k = 0, _ref2 = this.verticesNormals.length - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        vnA[i] = this.verticesNormals[i];
      }
      fnA = new Float32Array(this.facesNormals.length);
      for (i = _l = 0, _ref3 = this.facesNormals.length - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
        fnA[i] = this.facesNormals[i];
      }
      posBase = this.arrayBufferToBase64(posA.buffer);
      baseString = posBase;
      baseString += '|';
      indBase = this.arrayBufferToBase64(indA.buffer);
      baseString += indBase;
      baseString += '|';
      vnBase = this.arrayBufferToBase64(vnA.buffer);
      baseString += vnBase;
      baseString += '|';
      fnBase = this.arrayBufferToBase64(fnA.buffer);
      baseString += fnBase;
      baseString += '|' + this.originalFileName;
      return baseString;
    };

    OptimizedModel.prototype.fromBase64 = function(base64String) {
      var strArray;
      strArray = base64String.split('|');
      this.vertices = this.base64ToFloat32Array(strArray[0]);
      this.indices = new this.base64ToInt32Array(strArray[1]);
      this.verticesNormals = this.base64ToFloat32Array(strArray[2]);
      this.facesNormals = this.base64ToFloat32Array(strArray[3]);
      return this.originalFileName = strArray[4];
    };

    OptimizedModel.prototype.base64ToFloat32Array = function(b64) {
      var decoded, i, numFloats, pview, result, _i, _ref;
      numFloats = (base64ByteLength(b64.length)) / 4;
      result = new Float32Array(numFloats);
      decoded = stringToUint8Array(atob(b64));
      pview = new DataView(decoded.buffer);
      for (i = _i = 0, _ref = numFloats - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        result[i] = pview.getFloat32(i * 4, true);
      }
      return result;
    };

    OptimizedModel.prototype.base64ToInt32Array = function(b64) {
      var decoded, i, numInts, pview, result, _i, _ref;
      numInts = (base64ByteLength(b64.length)) / 4;
      result = new Int32Array(numInts);
      decoded = stringToUint8Array(atob(b64));
      pview = new DataView(decoded.buffer);
      for (i = _i = 0, _ref = numInts - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        result[i] = pview.getInt32(i * 4, true);
      }
      return result;
    };

    OptimizedModel.prototype.arrayBufferToBase64 = function(buffer) {
      var binary, bytes, i, len, _i, _ref;
      binary = '';
      bytes = new Uint8Array(buffer);
      len = bytes.byteLength;
      for (i = _i = 0, _ref = len - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    };

    OptimizedModel.prototype.convertToThreeGeometry = function(bufferGeometry) {
      if (bufferGeometry == null) {
        bufferGeometry = false;
      }
      if (bufferGeometry) {
        return this.createBufferGeometry();
      } else {
        return this.createStandardGeometry();
      }
    };

    OptimizedModel.prototype.createBufferGeometry = function() {
      var geometry, i, iarray, narray, parray, _i, _j, _k, _ref, _ref1, _ref2;
      geometry = new THREE.BufferGeometry();
      parray = new Float32Array(this.vertices.length);
      for (i = _i = 0, _ref = this.vertices.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        parray[i] = this.vertices[i];
      }
      narray = new Float32Array(this.verticesNormals.length);
      for (i = _j = 0, _ref1 = this.verticesNormals.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        narray[i] = this.verticesNormals[i];
      }
      iarray = new Uint32Array(this.indices.length);
      for (i = _k = 0, _ref2 = this.indices.length - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        iarray[i] = this.indices[i];
      }
      geometry.addAttribute('index', new THREE.BufferAttribute(iarray, 1));
      geometry.addAttribute('position', new THREE.BufferAttribute(parray, 3));
      geometry.addAttribute('normal', new THREE.BufferAttribute(narray, 3));
      geometry.computeBoundingSphere();
      return geometry;
    };

    OptimizedModel.prototype.createStandardGeometry = function() {
      var fi, geometry, vi, _i, _j, _ref, _ref1;
      geometry = new THREE.Geometry();
      for (vi = _i = 0, _ref = this.vertices.length - 1; _i <= _ref; vi = _i += 3) {
        geometry.vertices.push(new THREE.Vector3(this.vertices[vi], this.vertices[vi + 1], this.vertices[vi + 2]));
      }
      for (fi = _j = 0, _ref1 = this.indices.length - 1; _j <= _ref1; fi = _j += 3) {
        geometry.faces.push(new THREE.Face3(this.indices[fi], this.indices[fi + 1], this.indices[fi + 2], new THREE.Vector3(this.facesNormals[fi], this.facesNormals[fi + 1], this.facesNormals[fi + 2])));
      }
      return geometry;
    };

    OptimizedModel.prototype.fromThreeGeometry = function(threeGeometry, originalFileName) {
      var face, vertex, _i, _j, _len, _len1, _ref, _ref1, _results;
      if (originalFileName == null) {
        originalFileName = 'Three.Geometry';
      }
      this.vertices = [];
      this.indices = [];
      this.facesNormals = [];
      this.verticesNormals = [];
      this.originalFileName = originalFileName;
      _ref = threeGeometry.verticesCoordinates;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        vertex = _ref[_i];
        this.vertices.push(vertex.x);
        this.vertices.push(vertex.y);
        this.vertices.push(vertex.z);
      }
      _ref1 = threeGeometry.faces;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        face = _ref1[_j];
        this.indices.push(face.a);
        this.indices.push(face.b);
        this.indices.push(face.c);
        this.facesNormals.push(face.normal.x);
        this.facesNormals.push(face.normal.y);
        _results.push(this.facesNormals.push(face.normal.z));
      }
      return _results;
    };

    OptimizedModel.prototype.boundingBox = function() {
      var i, maxX, maxY, maxZ, minX, minY, minZ, _i, _ref;
      if (this._boundingBox) {
        return this._boundingBox;
      }
      minX = maxX = this.vertices[0];
      minY = maxY = this.vertices[1];
      minZ = maxZ = this.vertices[2];
      for (i = _i = 0, _ref = this.vertices.length - 1; _i <= _ref; i = _i += 3) {
        if (this.vertices[i] < minX) {
          minX = this.vertices[i];
        }
        if (this.vertices[i + 1] < minY) {
          minY = this.vertices[i + 1];
        }
        if (this.vertices[i + 2] < minZ) {
          minZ = this.vertices[i + 2];
        }
        if (this.vertices[i] > maxX) {
          maxX = this.vertices[i];
        }
        if (this.vertices[i + 1] > maxY) {
          maxY = this.vertices[i + 1];
        }
        if (this.vertices[i + 2] > maxZ) {
          maxZ = this.vertices[i + 2];
        }
      }
      this._boundingBox = {
        min: {
          x: minX,
          y: minY,
          z: minZ
        },
        max: {
          x: maxX,
          y: maxY,
          z: maxZ
        }
      };
      return this._boundingBox;
    };

    OptimizedModel.prototype.forEachPolygon = function(callback) {
      var i, n, p0, p1, p2, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.indices.length - 1; _i <= _ref; i = _i += 3) {
        p0 = {
          x: this.vertices[this.indices[i] * 3],
          y: this.vertices[this.indices[i] * 3 + 1],
          z: this.vertices[this.indices[i] * 3 + 2]
        };
        p1 = {
          x: this.vertices[this.indices[i + 1] * 3],
          y: this.vertices[this.indices[i + 1] * 3 + 1],
          z: this.vertices[this.indices[i + 1] * 3 + 2]
        };
        p2 = {
          x: this.vertices[this.indices[i + 2] * 3],
          y: this.vertices[this.indices[i + 2] * 3 + 1],
          z: this.vertices[this.indices[i + 2] * 3 + 2]
        };
        n = {
          x: this.facesNormals[i],
          y: this.facesNormals[i + 1],
          z: this.facesNormals[i + 2]
        };
        _results.push(callback(p0, p1, p2, n));
      }
      return _results;
    };

    return OptimizedModel;

  })();

  module.exports = OptimizedModel;

}).call(this);
