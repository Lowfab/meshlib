// Generated by CoffeeScript 1.9.0
(function() {
  var Hashmap, OptimizedModel, compactClasses, createEquivalenceClasses, createModelFromEquivalenceClass,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  OptimizedModel = require('./../OptimizedModel');

  createModelFromEquivalenceClass = function(equivalenceClass, optimizedModel) {
    var insertPoint, model, nextPointIndex, polyTranslationTable;
    nextPointIndex = 0;
    polyTranslationTable = {};
    model = new OptimizedModel();
    insertPoint = function(currentId) {
      if (polyTranslationTable[currentId] == null) {
        polyTranslationTable[currentId] = nextPointIndex;
        nextPointIndex++;
        model.verticesCoordinates.push(optimizedModel.verticesCoordinates[currentId * 3]);
        model.verticesCoordinates.push(optimizedModel.verticesCoordinates[currentId * 3 + 1]);
        model.verticesCoordinates.push(optimizedModel.verticesCoordinates[currentId * 3 + 2]);
        model.verticesNormals.push(optimizedModel.verticesNormals[currentId * 3]);
        model.verticesNormals.push(optimizedModel.verticesNormals[currentId * 3 + 1]);
        model.verticesNormals.push(optimizedModel.verticesNormals[currentId * 3 + 2]);
      }
      return polyTranslationTable[currentId];
    };
    equivalenceClass.faces.enumerate(function(pi) {
      var p0, p0n, p1, p1n, p2, p2n;
      p0 = optimizedModel.facesVerticesIndices[pi * 3];
      p1 = optimizedModel.facesVerticesIndices[pi * 3 + 1];
      p2 = optimizedModel.facesVerticesIndices[pi * 3 + 2];
      p0n = insertPoint(p0);
      p1n = insertPoint(p1);
      p2n = insertPoint(p2);
      model.facesVerticesIndices.push(p0n);
      model.facesVerticesIndices.push(p1n);
      model.facesVerticesIndices.push(p2n);
      model.facesNormals.push(optimizedModel.facesNormals[pi * 3]);
      model.facesNormals.push(optimizedModel.facesNormals[pi * 3 + 1]);
      return model.facesNormals.push(optimizedModel.facesNormals[pi * 3 + 2]);
    });
    return model;
  };

  createEquivalenceClasses = function(optimizedModel) {
    var combined, connectedClasses, eq, equivalenceClasses, faceIndex, poly, _i, _j, _len, _ref;
    equivalenceClasses = [];
    for (faceIndex = _i = 0, _ref = optimizedModel.facesVerticesIndices.length - 1; _i <= _ref; faceIndex = _i += 3) {
      poly = {
        index: faceIndex / 3,
        p0: optimizedModel.facesVerticesIndices[faceIndex],
        p1: optimizedModel.facesVerticesIndices[faceIndex + 1],
        p2: optimizedModel.facesVerticesIndices[faceIndex + 2]
      };
      connectedClasses = [];
      for (_j = 0, _len = equivalenceClasses.length; _j < _len; _j++) {
        eq = equivalenceClasses[_j];
        if (eq.points.exists(poly.p0) || eq.points.exists(poly.p1) || eq.points.exists(poly.p2)) {
          eq.points.push(poly.p0);
          eq.points.push(poly.p1);
          eq.points.push(poly.p2);
          eq.faces.push(poly.index);
          connectedClasses.push(eq);
        }
      }
      if (connectedClasses.length === 0) {
        eq = {
          points: new Hashmap(),
          faces: new Hashmap()
        };
        eq.points.push(poly.p0);
        eq.points.push(poly.p1);
        eq.points.push(poly.p2);
        eq.faces.push(poly.index);
        equivalenceClasses.push(eq);
      } else if (connectedClasses.length > 1) {
        combined = compactClasses(connectedClasses);
        equivalenceClasses.push(combined);
        equivalenceClasses = equivalenceClasses.filter(function(a) {
          return a.points.length > 0;
        });
      }
    }
    return equivalenceClasses;
  };

  compactClasses = function(equivalenceClasses) {
    var eq, newClass, _i, _len;
    newClass = {
      points: new Hashmap(),
      faces: new Hashmap()
    };
    for (_i = 0, _len = equivalenceClasses.length; _i < _len; _i++) {
      eq = equivalenceClasses[_i];
      eq.points.enumerate(function(point) {
        return newClass.points.push(point);
      });
      eq.faces.enumerate(function(face) {
        return newClass.faces.push(face);
      });
      eq.points = new Hashmap();
      eq.faces = new Hashmap();
    }
    return newClass;
  };

  Hashmap = (function() {
    function Hashmap() {
      this.enumerate = __bind(this.enumerate, this);
      this.exists = __bind(this.exists, this);
      this.push = __bind(this.push, this);
      this.length = 0;
      this._enumarray = [];
      this._existsarray = [];
    }

    Hashmap.prototype.push = function(number) {
      if (!this._existsarray[number]) {
        this.length++;
        this._existsarray[number] = true;
        return this._enumarray.push(number);
      }
    };

    Hashmap.prototype.exists = function(number) {
      if (this._existsarray[number] != null) {
        return true;
      }
      return false;
    };

    Hashmap.prototype.enumerate = function(callback) {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this._enumarray.length - 1; _i <= _ref; i = _i += 1) {
        _results.push(callback(this._enumarray[i]));
      }
      return _results;
    };

    return Hashmap;

  })();

  module.exports = function(optimizedModel) {
    var eq, equivalenceClasses, models, _i, _len;
    models = [];
    equivalenceClasses = createEquivalenceClasses(optimizedModel);
    if (equivalenceClasses.length === 1) {
      models.push(optimizedModel);
    } else {
      for (_i = 0, _len = equivalenceClasses.length; _i < _len; _i++) {
        eq = equivalenceClasses[_i];
        models.push(createModelFromEquivalenceClass(eq, optimizedModel));
      }
    }
    return models;
  };

}).call(this);
