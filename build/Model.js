// Generated by CoffeeScript 1.9.0
(function() {
  var Face, Model, NoFacesError, Vector, buildFaceVertexMesh, geometrySplitter, testTwoManifoldness,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Vector = require('./primitives/Vector');

  Face = require('./primitives/Face');

  geometrySplitter = require('./helpers/separateGeometry');

  buildFaceVertexMesh = require('./helpers/buildFaceVertexMesh');

  testTwoManifoldness = require('./helpers/testTwoManifoldness');

  NoFacesError = require('./errors/NoFacesError');

  Model = (function() {
    function Model(_at_mesh, _at_options) {
      this.mesh = _at_mesh;
      this.options = _at_options;
      this.getSubmodels = __bind(this.getSubmodels, this);
      this.calculateNormals = __bind(this.calculateNormals, this);
      this.fixFaces = __bind(this.fixFaces, this);
      this.setFaces = __bind(this.setFaces, this);
      this.buildFaceVertexMesh = __bind(this.buildFaceVertexMesh, this);
      if (this.mesh == null) {
        this.mesh = {
          faces: [],
          faceVertex: {}
        };
      }
      if (this.options == null) {
        this.options = {};
      }
    }

    Model.prototype.buildFaceVertexMesh = function() {
      this.mesh.faceVertex = buildFaceVertexMesh(this.mesh.faces);
      return this;
    };

    Model.prototype.setFaces = function(faces) {
      this.mesh.faces = faces;
      return this;
    };

    Model.prototype.fixFaces = function() {
      var deletedFaces;
      deletedFaces = [];
      if (this.mesh.faces) {
        this.mesh.faces = this.mesh.faces.map(function(face) {
          if (face.vertices.length === 3) {
            return face;
          } else if (face.vertices.length > 3) {
            deletedFaces.push(face);
            face.vertices = face.vertices.slice(0, 3);
            return face;
          } else if (face.vertices.length === 2) {
            face.addVertex(new Vector(0, 0, 0));
            return face;
          } else if (face.vertices.length === 1) {
            face.addVertex(new Vector(0, 0, 0));
            face.addVertex(new Vector(1, 1, 1));
            return face;
          } else {
            return null;
          }
        });
      } else {
        throw new NoFacesError;
      }
      return this;
    };

    Model.prototype.calculateNormals = function() {
      var newNormals;
      newNormals = [];
      if (this.mesh.faces) {
        this.mesh.faces = this.mesh.faces.map(function(face) {
          var d1, d2, distance, normal;
          face = Face.fromVertexArray(face.vertices);
          d1 = Vector.fromObject(face.vertices[1]).minus(Vector.fromObject(face.vertices[0]));
          d2 = Vector.fromObject(face.vertices[2]).minus(Vector.fromObject(face.vertices[0]));
          normal = d1.crossProduct(d2);
          normal = normal.normalized();
          if (face.normal != null) {
            distance = face.normal.euclideanDistanceTo(normal);
            if (distance > 0.001) {
              newNormals.push(normal);
            }
          }
          face.normal = normal;
          return face;
        });
      } else {
        throw new NoFacesError;
      }
      return this;
    };

    Model.prototype.getSubmodels = function() {
      return geometrySplitter(this.mesh);
    };

    Model.prototype.isTwoManifold = function() {
      if (this._isTwoManifold == null) {
        this._isTwoManifold = testTwoManifoldness(this.mesh.faceVertex);
      }
      return this._isTwoManifold;
    };

    return Model;

  })();

  module.exports = Model;

}).call(this);
